name: IP File Distribution

on:
  workflow_dispatch:  # Manual execution via GitHub interface
  schedule:
    - cron: '0 */3 * * *'  # Runs every 3 hours
  push:  # Trigger when the repository is updated
    branches:
      - main  # Replace 'main' with your default branch if different

jobs:
  send-files:
    runs-on: ubuntu-latest

    env:
      CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      FILES: export.json ipv4.json ipv6.json full lite # Define files in a variable
      EXPORT_URL: "https://raw.githubusercontent.com/ircfspace/cf2dns/refs/heads/master/list/export.json"
      IPV4_URL: "https://raw.githubusercontent.com/ircfspace/cf2dns/refs/heads/master/list/ipv4.json"
      IPV6_URL: "https://raw.githubusercontent.com/ircfspace/cf2dns/refs/heads/master/list/ipv6.json"
      FULL_URL: "https://raw.githubusercontent.com/ircfspace/warpkey/main/plus/full"
      LITE_URL: "https://raw.githubusercontent.com/ircfspace/warpkey/main/plus/lite"

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Download Files
        run: |
          curl --retry 3 -o export.json "$EXPORT_URL"
          curl --retry 3 -o ipv4.json "$IPV4_URL"
          curl --retry 3 -o ipv6.json "$IPV6_URL"
          curl --retry 3 -o full "$FULL_URL"
          curl --retry 3 -o lite "$LITE_URL"

      - name: Send Files to Telegram
        run: |
          for file in $FILES; do # Iterate over the FILES variable
            case "$file" in # Quote the $file variable for safety
              export.json)
                caption="ðŸ“‚ *Export Data File* \n \n Comprehensive dataset for analysis." ;;
              ipv4.json)
                caption="ðŸŒ *IPv4 Addresses*\n\nList of IPv4 addresses for network analysis." ;;
              ipv6.json)
                caption="ðŸŒ *IPv6 Addresses*\n\nList of IPv6 addresses for network analysis." ;;
              full)
                caption="ðŸ“‹ *Full Data File*\n\nDetailed dataset for extensive analysis." ;;
              lite)
                caption="ðŸ“‘ *Lite Data File*\n\nStreamlined dataset for quick analysis." ;;
            esac

            # Use a more robust way to check for errors
            curl --retry 3 -s -w "%{http_code}" -o /dev/null -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendDocument" \
              -F chat_id="$CHAT_ID" \
              -F document=@"$file" \
              -F caption="$caption" \
              -F parse_mode="Markdown" > /dev/null 2>&1  # Redirect output and errors

            http_code=$(curl --retry 3 -s -w "%{http_code}" -o /dev/null -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendDocument" \
              -F chat_id="$CHAT_ID" \
              -F document=@"$file" \
              -F caption="$caption" \
              -F parse_mode="Markdown" | grep -oP 'HTTP/\d\.\d (\d{3})' | awk '{print $2}')

            if [[ "$http_code" != "200" ]]; then
              echo "Failed to send $file to Telegram. HTTP response code: $http_code"
              exit 1 # Stop the workflow if sending any file fails
            fi

            echo "Successfully sent $file to Telegram." # Confirmation message
          done

      - name: Clean up
        if: always() # Always run cleanup, even if previous steps fail
        run: |
          rm -f $FILES # Use the FILES variable for cleanup
